!
!  THIS CODE IS AUTOMATICALLY GENERATED.
!  DO NOT MODIFY IT DIRECTLY.
!
! Interface for the fortran speedy module.
!
!
! This interface follows the ideas presented in this paper:
! "Exposing Fortran Derived Types to C and Other Languages"
! S. Kruger, S. Muszala, A. Pletzer, S. Vadlamani and D. McCune,
! Computing in Science & Engineering, vol. 10, no. 04, pp. 86-92, 2008.
! doi: 10.1109/MCSE.2008.94
!
! https://doi.ieeecomputersociety.org/10.1109/MCSE.2008.94

module pyspeedy
    use model_state, only: ModelState_allocate, ModelState_deallocate, ModelState_t, ModelState_Ptr_t
    use types, only : p

    implicit none

contains

    !> Initialize the Speedy modules. This needs to be run once.
    subroutine initialize()
        use initialization, only: initialize_modules
        call initialize_modules()
    end subroutine

    !> Deinitialize the Speedy modules.
    subroutine close()
        use initialization, only: deinitialize_modules
        call deinitialize_modules()
    end subroutine


    !> Initialize the ModelState and return the container with the object.
    subroutine modelstate_initialize(this)
        integer(8), intent(out) :: this !! Container for the ModelState_Ptr_t object.

        type(ModelState_Ptr_t) :: this_ptr
        allocate (this_ptr%p)
        call ModelState_allocate(this_ptr%p)
        this = transfer(this_ptr, this)
    end subroutine

    !> Deallocate the ModelState
    subroutine modelstate_close(this)
        
        integer(8), intent(in) :: this

        type(ModelState_Ptr_t):: this_ptr

        this_ptr = transfer(this, this_ptr)
        call ModelState_deallocate(this_ptr%p)
    end subroutine

    subroutine run(this, history_interval, diagnostic_interval)
        use speedy, only: run_speedy
        
        integer(8), intent(in) :: this
        integer, intent(in) :: history_interval, diagnostic_interval

        type(ModelState_Ptr_t):: this_ptr

        this_ptr = transfer(this, this_ptr)
        call run_speedy(this_ptr%p, history_interval, diagnostic_interval)
    end subroutine

    subroutine create_datetime(year, month, day, hour, minute, datetime_container)
        use date, only: Datetime_t, Datetime_Ptr_t

        integer, intent(in) :: year, month, day,hour, minute
        integer(8), intent(out) :: datetime_container       

        type(Datetime_Ptr_t):: datetime_out
        type(Datetime_t), pointer :: my_datetime

        ! 1. Create the fortran datetime_t object.
        ! We make it allocatable because we want to return the reference pointing to
        ! this object.        
        allocate(my_datetime)
        my_datetime%allocated = .true.
        my_datetime%year = year
        my_datetime%month = month
        my_datetime%day = day
        my_datetime%hour = hour
        my_datetime%minute = minute
        
        ! 2. Make the container point to that object.
        datetime_out%p => my_datetime

        ! 3. Return the container with the memory address to the datetime object.
        datetime_container = transfer(datetime_out, datetime_container)
    end subroutine

    subroutine get_datetime(this, year, month, day, hour, minute)
        use date, only: Datetime_t, Datetime_Ptr_t
       
        integer(8), intent(in) :: this
        
        integer, intent(out) :: year, month, day, hour, minute
        type(Datetime_Ptr_t):: this_ptr

        this_ptr = transfer(this, this_ptr)

        year = this_ptr%p%year
        month = this_ptr%p%month
        day = this_ptr%p%day
        hour = this_ptr%p%hour
        minute = this_ptr%p%minute       
    end subroutine

    subroutine close_datetime(this)
        use date, only: Datetime_t, Datetime_Ptr_t       
        integer(8), intent(in) :: this

        type(Datetime_Ptr_t):: this_ptr

        this_ptr = transfer(this, this_ptr)
        if (this_ptr%p%allocated) deallocate(this_ptr%p)
    end subroutine


    {% for var in model_state %}

    subroutine get_{{var.name}}(this, {{ var.name }}_out)
        use params
        integer(8), intent(in) :: this
        !> {{ var.desc }}
        {{ var.dtype }}(8), intent(out) :: {{ var.name }}_out{{ var.dims }}
        type(ModelState_Ptr_t):: this_ptr

        this_ptr = transfer(this, this_ptr)
        {{ var.name }}_out=this_ptr%p%{{ var.name }}
    end subroutine

    subroutine set_{{var.name}}(this, {{ var.name }}_in)
        use params
        integer(8), intent(in) :: this
        !> {{ var.desc }}
        {{ var.dtype }}(8), intent(in) :: {{ var.name }}_in{{ var.dims }}
        type(ModelState_Ptr_t):: this_ptr

        this_ptr = transfer(this, this_ptr)
        this_ptr%p%{{ var.name }}={{ var.name }}_in
    end subroutine

    subroutine get_{{var.name}}_shape(this, array_shape)
        use params
        integer(8), intent(in) :: this
        !> {{ var.desc }}
        integer, intent(out) :: array_shape({{ var.ndim }})
        type(ModelState_Ptr_t):: this_ptr

        this_ptr = transfer(this, this_ptr)
        array_shape=shape(this_ptr%p%{{ var.name }})
    end subroutine
    {% endfor %}
end module

